/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package interview.chessroute;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.function.Consumer;
import java.util.stream.Stream;

public class App {
    static Set<Tile> initBoard(int size) {
        assert 0 <= size && size < 100;
        final ImmutableSet.Builder<Tile> board = ImmutableSet.builder();
        for (int r = 0; r < size; r++) {
            for (int c = 0; c < size; c++) {
                board.add(new Tile(r, c));
            }
        }
        return board.build();
    }

    static Set<Tile> movesFrom(Tile tile) {
        return ImmutableSet.of(
                // Same row or column
                new Tile(tile.row - 2, tile.col),
                new Tile(tile.row + 2, tile.col),
                new Tile(tile.row, tile.col - 2),
                new Tile(tile.row, tile.col + 2),
                // Diagonal
                new Tile(tile.row - 1, tile.col - 1),
                new Tile(tile.row - 1, tile.col + 1),
                new Tile(tile.row + 1, tile.col - 1),
                new Tile(tile.row + 1, tile.col + 1));
    }

    static Stream<Tile> allowedMovesFrom(Set<Tile> board, Tile tile) {
        return movesFrom(tile).stream().filter(board::contains);
    }

    static class Route {
        final Route prev;
        final Tile tile;

        Route(Route prev, Tile tile) {
            this.prev = prev;
            this.tile = tile;
        }

        public List<Tile> toList() {
            final var result = new ArrayList<Tile>();
            var r = this;
            while (r != null) {
                result.add(r.tile);
                r = r.prev;
            }
            return Lists.reverse(result);
        }
    }

    ImmutableSet<Tile> takeStep(Set<Tile> board, Tile step) {
        // XXX Inefficient - scans whole board every time. Use Clojure's hash set here?
        return board.stream()
                .filter((t) -> t.equals(step))
                .collect(ImmutableSet.toImmutableSet());
    }

    void findRoute(Set<Tile> board, Route route, Consumer<List<Tile>> resultHandler) {
        if (board.isEmpty()) {
            resultHandler.accept(route.toList());
        } else {
            allowedMovesFrom(board, route.tile).forEach((step) ->
                    findRoute(
                            takeStep(board, step),
                            new Route(route, step),
                            resultHandler));
        }
    }

    void findAllRoutes(int size, Consumer<List<Tile>> resultHandler) {
         var board = initBoard(size);
        for (Tile start : board) {
            findRoute(board, new Route(null, start), resultHandler);
        }
    }

    public static void main(String[] args) {
        new App().findAllRoutes(10, System.out::println);
    }
}
